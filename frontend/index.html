<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice Assistant | Premium</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <!-- Google Identity Services for OAuth 2.0 -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
      :root {
        --bg-gradient-1: #0f0c29;
        --bg-gradient-2: #302b63;
        --bg-gradient-3: #24243e;
        --accent-color: #00f2ff;
        --accent-secondary: #bd00ff;
        --glass-bg: rgba(255, 255, 255, 0.05);
        --glass-border: rgba(255, 255, 255, 0.1);
        --text-color: #ffffff;
        --text-muted: #a0a0a0;
      }

      * {
        box-sizing: border-box;
        outline: none;
      }

      body {
        margin: 0;
        font-family: "Outfit", sans-serif;
        background: linear-gradient(
          -45deg,
          var(--bg-gradient-1),
          var(--bg-gradient-2),
          var(--bg-gradient-3)
        );
        background-size: 400% 400%;
        animation: gradientBG 15s ease infinite;
        color: var(--text-color);
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      @keyframes gradientBG {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* --- Immersive Card --- */
      #app-container {
        width: 90%;
        max-width: 900px;
        height: 90vh;
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 24px;
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        display: flex;
        flex-direction: column;
        position: relative;
      }

      /* --- Header --- */
      header {
        padding: 20px 30px;
        border-bottom: 1px solid var(--glass-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .status-badge {
        font-size: 12px;
        padding: 6px 12px;
        border-radius: 20px;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #444;
        transition: background 0.3s;
      }
      .status-dot.connected {
        background: #00ff88;
        box-shadow: 0 0 8px #00ff88;
      }
      .status-dot.listening {
        background: #ff4d4d;
        box-shadow: 0 0 8px #ff4d4d;
        animation: pulse 1s infinite;
      }
      .status-dot.speaking {
        background: var(--accent-color);
        box-shadow: 0 0 8px var(--accent-color);
      }

      /* --- Auth Button & User Info --- */
      #auth-container {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      #google-signin-btn {
        padding: 8px 16px;
        background: white;
        color: #1f1f1f;
        border: none;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
      }

      #google-signin-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
      }

      #user-info {
        display: none;
        font-size: 12px;
        color: var(--text-muted);
        padding: 6px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 20px;
      }

      #user-info.visible {
        display: block;
      }

      #signout-btn {
        padding: 4px 12px;
        background: transparent;
        color: var(--text-muted);
        border: 1px solid var(--glass-border);
        border-radius: 15px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        margin-left: 8px;
      }

      #signout-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-color);
      }

      /* --- Visualizer --- */
      #visualizer-container {
        height: 120px;
        width: 100%;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.2);
      }
      canvas {
        width: 100%;
        height: 100%;
      }

      /* --- Chat Area --- */
      #chat-scroll {
        flex: 1;
        overflow-y: auto;
        padding: 20px 30px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        scroll-behavior: smooth;
      }

      #chat-scroll::-webkit-scrollbar {
        width: 6px;
      }
      #chat-scroll::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .message {
        max-width: 80%;
        padding: 14px 20px;
        border-radius: 18px;
        font-size: 16px;
        line-height: 1.5;
        animation: fadeIn 0.4s ease-out;
      }

      .message.user {
        align-self: flex-end;
        background: linear-gradient(135deg, var(--accent-secondary), #8e2de2);
        color: white;
        border-bottom-right-radius: 4px;
      }

      .message.system {
        align-self: flex-start;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--glass-border);
        border-bottom-left-radius: 4px;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* --- Controls --- */
      #controls {
        padding: 20px;
        border-top: 1px solid var(--glass-border);
        display: flex;
        align-items: center;
        gap: 15px;
      }

      input[type="text"] {
        flex: 1;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid var(--glass-border);
        padding: 14px 20px;
        border-radius: 30px;
        color: white;
        font-size: 16px;
        font-family: inherit;
        transition: all 0.3s;
      }
      input[type="text"]:focus {
        background: rgba(0, 0, 0, 0.4);
        border-color: var(--accent-color);
      }

      .btn-mic {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, var(--accent-color), #00c6ff);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s, box-shadow 0.2s;
        font-size: 24px;
        color: #0f0c29;
      }

      .btn-mic:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
      }

      .btn-mic.recording {
        background: #ff4d4d;
        animation: pulse-border 1.5s infinite;
        color: white;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      @keyframes pulse-border {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 77, 77, 0.7);
        }
        70% {
          box-shadow: 0 0 0 15px rgba(255, 77, 77, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 77, 77, 0);
        }
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <header>
        <div style="font-weight: 600; font-size: 20px; letter-spacing: 1px">
          VIRTUAL <span style="color: var(--accent-color)">ASSISTANT</span>
        </div>
        <div id="auth-container">
          <!-- Google Sign-In Button (hidden when authenticated) -->
          <button id="google-signin-btn">
            <svg width="18" height="18" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
              <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path>
              <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path>
              <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path>
              <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path>
              <path fill="none" d="M0 0h48v48H0z"></path>
            </svg>
            Sign in with Google
          </button>
          <!-- User Info (hidden initially) -->
          <div id="user-info">
            <span id="user-email"></span>
            <button id="signout-btn">Sign out</button>
          </div>
        </div>
        <div class="status-badge">
          <div id="status-dot" class="status-dot"></div>
          <span id="status-text">Connecting...</span>
        </div>
      </header>

      <div id="visualizer-container">
        <canvas id="visualizer"></canvas>
      </div>

      <div id="chat-scroll">
        <!-- Messages go here -->
      </div>

      <div id="controls">
        <input
          type="text"
          id="text-input"
          placeholder="Type a message..."
          autocomplete="off"
        />
        <button id="mic-btn" class="btn-mic" title="Hold to Speak">ðŸŽ¤</button>
      </div>
    </div>

    <script>
      const chatScroll = document.getElementById("chat-scroll");
      const textInput = document.getElementById("text-input");
      const micBtn = document.getElementById("mic-btn");
      const statusDot = document.getElementById("status-dot");
      const statusText = document.getElementById("status-text");
      const canvas = document.getElementById("visualizer");
      const ctx = canvas.getContext("2d");

      // Auth elements
      const googleSignInBtn = document.getElementById("google-signin-btn");
      const userInfo = document.getElementById("user-info");
      const userEmail = document.getElementById("user-email");
      const signoutBtn = document.getElementById("signout-btn");

      let ws;
      let mediaRecorder;
      let audioChunks = [];
      let audioContext;
      let analyser;
      let microphoneStream;
      let isVisActive = false;

      // Google OAuth
      let googleAccessToken = null;
      const GOOGLE_CLIENT_ID = "YOUR_GOOGLE_CLIENT_ID_HERE"; // User should replace this

      // --- Audio Visualizer ---
      function initVisualizer() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
        }
      }

      function drawVisualizer() {
        if (!isVisActive) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
        }

        requestAnimationFrame(drawVisualizer);

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const width = canvas.width;
        const height = canvas.height;
        const barWidth = (width / bufferLength) * 2.5;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const barHeight = dataArray[i] / 2;

          const gradient = ctx.createLinearGradient(
            0,
            height - barHeight,
            0,
            height
          );
          gradient.addColorStop(0, "#00f2ff");
          gradient.addColorStop(1, "#bd00ff");

          ctx.fillStyle = gradient;
          ctx.fillRect(x, height - barHeight, barWidth, barHeight);
          x += barWidth + 2;
        }
      }

      function resizeCanvas() {
        canvas.width = document.getElementById(
          "visualizer-container"
        ).offsetWidth;
        canvas.height = document.getElementById(
          "visualizer-container"
        ).offsetHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // --- Messaging ---
      function addMessage(text, sender) {
        if (!text) return;
        const msgDiv = document.createElement("div");
        msgDiv.className = `message ${sender}`;
        msgDiv.textContent = text;
        chatScroll.appendChild(msgDiv);
        chatScroll.scrollTop = chatScroll.scrollHeight;
      }

      function updateStatus(state) {
        statusDot.className = "status-dot " + state;
        if (state === "connected") statusText.textContent = "Online";
        if (state === "listening") statusText.textContent = "Listening...";
        if (state === "speaking") statusText.textContent = "Speaking...";
        if (state === "disconnected") statusText.textContent = "Offline";
      }

      // --- Audio Playback ---
      function playAudioFromBase64(base64) {
        if (!base64) return;

        const audio = new Audio("data:audio/wav;base64," + base64);
        updateStatus("speaking");

        // Simple visualization for output audio (simulated relative to duration)
        // NOTE: Perfect output visualization requires connecting to AudioContext destination,
        // but for simplicity we'll just indicate state here.

        audio.onended = () => {
          updateStatus("connected");
        };

        audio.play().catch((e) => console.error("Playback failed", e));
      }

      // --- Google OAuth 2.0 ---
      function initGoogleAuth() {
        if (typeof google === 'undefined') {
          console.warn("Google Identity Services not loaded yet, retrying...");
          setTimeout(initGoogleAuth, 500);
          return;
        }

        // Initialize Token Client for OAuth 2.0
        const tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: 'https://www.googleapis.com/auth/calendar.events openid profile email',
          callback: (response) => {
            if (response.error) {
              console.error('OAuth error:', response);
              alert('Failed to sign in with Google');
              return;
            }

            // Store the access token
            googleAccessToken = response.access_token;
            sessionStorage.setItem('google_access_token', googleAccessToken); // Persist
            console.log('Google OAuth successful, token received');

            // Update UI
            googleSignInBtn.style.display = 'none';
            userInfo.classList.add('visible');
            
            // Get user email using the ID token endpoint (optional, for display)
            fetchUserEmail(googleAccessToken);
            
            // Reconnect WebSocket with new token if already connected
            if (ws) {
                console.log("Reconnecting WebSocket with new token");
                ws.close(); // validation will trigger reconnect in onclose
                // or we can just send the auth message if we don't want to reconnect
                // But to reset the graph state to START with user info, reconnecting is cleaner
            } else {
                sendAuthToken();
            }
          },
        });

        // Check for persisted token on load
        const storedToken = sessionStorage.getItem('google_access_token');
        if (storedToken) {
             googleAccessToken = storedToken;
             googleSignInBtn.style.display = 'none';
             userInfo.classList.add('visible');
             fetchUserEmail(googleAccessToken);
        }

        // Sign-in button click handler
        googleSignInBtn.addEventListener('click', () => {
          tokenClient.requestAccessToken({ prompt: 'consent' });
        });

        // Sign-out button
        signoutBtn.addEventListener('click', () => {
          googleAccessToken = null;
          sessionStorage.removeItem('google_access_token');
          googleSignInBtn.style.display = 'flex';
          userInfo.classList.remove('visible');
          userEmail.textContent = '';
          console.log('Signed out');
          // Reconnect to clear backend state
          if (ws) ws.close();
        });
      }
      


      function fetchUserEmail(token) {
        // Use the userinfo endpoint to get email
        fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
          headers: { Authorization: `Bearer ${token}` }
        })
        .then(res => res.json())
        .then(data => {
          userEmail.textContent = `Signed in as ${data.email}`;
        })
        .catch(err => {
          console.error('Failed to fetch user email:', err);
          userEmail.textContent = 'Signed in';
        });
     }

      function sendAuthToken() {
        // Legacy message-based auth (backup)
        if (ws && ws.readyState === WebSocket.OPEN && googleAccessToken) {
          ws.send(JSON.stringify({
            type: 'auth',
            payload: { google_token: googleAccessToken }
          }));
        }
      }

      // --- WebSocket ---
      function connect() {
        // Add token to query params if available
        let wsUrl = "ws://" + window.location.host + "/ws";
        if (googleAccessToken) {
            wsUrl += "?token=" + encodeURIComponent(googleAccessToken);
        }
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          updateStatus("connected");
          addMessage("Connected to Server", "system");
          // No need to sendAuthToken if we passed it in URL, but harmless redundancy
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);

            if (data.type === 'auth_error') {
                console.warn("Server rejected auth token - clearing persistence");
                sessionStorage.removeItem('google_access_token');
                googleAccessToken = null;
                googleSignInBtn.style.display = 'flex';
                userInfo.classList.remove('visible');
                userEmail.textContent = '';
                addMessage("Authentication invalid - signed out", "system");
            }
            
            if (data.status === 'authenticated') {
                 // Handled by message-based auth if needed
            }

            if (data.text) {
              addMessage(data.text, "system");
            }
            if (data.audio_b64) {
              playAudioFromBase64(data.audio_b64);
            }
          } catch (err) {
            console.error("Parse error", err);
          }
        };

        ws.onclose = () => {
          updateStatus("disconnected");
          addMessage("Disconnected", "system");
          setTimeout(connect, 3000); // Auto-reconnect
        };
      }

      // --- Text Input ---
      textInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const text = textInput.value.trim();
          if (text && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "text", payload: text }));
            addMessage(text, "user");
            textInput.value = "";
          }
        }
      });

      // --- Recording Logic ---
      async function startRecording() {
        try {
          initVisualizer();
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          // Connect stream to visualizer
          microphoneStream = audioContext.createMediaStreamSource(stream);
          microphoneStream.connect(analyser);
          isVisActive = true;
          drawVisualizer();

          mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);

          mediaRecorder.onstop = async () => {
            isVisActive = false;
            // cleanup visualizer
            if (microphoneStream) microphoneStream.disconnect();

            const blob = new Blob(audioChunks, { type: "audio/wav" });
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = () => {
              const base64Audio = reader.result.split(",")[1];
              if (ws.readyState === WebSocket.OPEN) {
                ws.send(
                  JSON.stringify({ type: "audio", payload: base64Audio })
                );
              }
            };

            // Stop tracks to release mic
            stream.getTracks().forEach((track) => track.stop());
          };

          mediaRecorder.start();
          micBtn.classList.add("recording");
          micBtn.innerHTML = "â¹"; // Stop icon
          updateStatus("listening");
        } catch (err) {
          console.error("Mic error", err);
          alert("Could not access microphone");
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
          micBtn.classList.remove("recording");
          micBtn.innerHTML = "ðŸŽ¤"; // Mic icon
          updateStatus("connected");
        }
      }

      micBtn.addEventListener("click", () => {
        if (micBtn.classList.contains("recording")) {
          stopRecording();
        } else {
          startRecording();
        }
      });

      // --- Init ---
      initGoogleAuth();
      connect();
    </script>
  </body>
</html>
